# Qt源码解析 [索引](https://blog.csdn.net/xinqingwuji/article/details/118365888)

# Qt源码解析4-事件系统

​	在Qt中，事件是由抽象类`QEvent`派生而来的对象，它表示应用程序内部发生的事情或应用程序需要知道的外部活动的结果。`QObject`子类的任何实例都可以接收和处理事件，但它们与小部件特别相关。本文档描述了在典型应用程序中如何交付和处理事件。

# 1、如何传递事件

​	当一个事件发生时，Qt 通过构造一个适当的`QEvent`子类的实例来创建一个事件对象来表示它，并通过调用它的`event()`函数将它传递给一个特定的`QObject`实例（或其子类之一） 。

该函数不处理事件本身；根据传递的事件类型，它为该特定类型的事件调用事件处理程序，并根据事件是被接受还是被忽略来发送响应。

一些事件，例如`QMouseEvent`和`QKeyEvent`，来自窗口系统；一些，例如`QTimerEvent`，来自其他来源；有些来自应用程序本身。

# 2、事件类型

 	大多数事件类型都有特殊的类，特别是`QResizeEvent`、`QPaintEvent`、`QMouseEvent`、`QKeyEvent`和`QCloseEvent`。每个类都是`QEvent`的子类，并添加特定于事件的函数。例如，`QResizeEvent`添加size()和`oldSize()`以使小部件能够发现它们的尺寸是如何更改的。

​	有些类支持一种以上的实际事件类型。`QMouseEvent`支持鼠标按键按下、双击、移动和其他相关操作。

​	每个事件都有一个关联的类型，定义在`QEvent:: type`中，它可以用作运行时类型信息的方便来源，以便快速确定给定事件对象是由哪个子类构造的。

​	由于程序需要以多种复杂的方式进行响应，Qt的事件交付机制非常灵活。`QCoreApplication::notify()`的文档简明地讲述了整个故事;Qt季刊的另一篇文章《Another Look at Events》对它进行了不那么简洁的重复。这里我们将对95%的应用进行足够的解释。

## 3、事件处理

​	传递事件的正常方式是调用虚函数。例如，`QPaintEvent`是通过调用`QWidget::paintEvent()`来传递的。这个虚函数负责作出适当的反应，通常是通过重新绘制小部件。如果没有在虚函数的实现中执行所有必要的工作，则可能需要调用基类的实现。

例如，下面的代码处理自定义复选框小部件上的鼠标左键点击，同时将所有其他按钮点击传递到基础的`QCheckBox`类:

```c++
void MyCheckBox::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        // handle left mouse button here
    } else {
        // pass on other buttons to base class
        QCheckBox::mousePressEvent(event);
    }
}
```

​	如果你想替换基类的函数，你必须自己实现所有的东西。但是，如果您只想扩展基类的功能，那么您可以实现您想要的，并调用基类来获得您不想处理的任何情况的默认行为。

​	有时候，没有这样一个特定于事件的函数，或者特定于事件的函数是不够的。最常见的例子是按Tab键。通常，`QWidget`拦截这些来移动键盘焦点，但是有一些小部件本身需要Tab键。

​	这些对象可以重新实现通用的事件处理程序`QObject::event()`，并在通常的处理之前或之后进行事件处理，或者它们可以完全替换该函数。一个非常不寻常的小部件，它既可以解释Tab，又有一个特定于应用程序的自定义事件，它可能包含以下事件()函数:

```c++
bool MyWidget::event(QEvent *event)
{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent *ke = static_cast<QKeyEvent *>(event);
        if (ke->key() == Qt::Key_Tab) {
            // special tab handling here
            return true;
        }
    } else if (event->type() == MyCustomEventType) {
        MyCustomEvent *myEvent = static_cast<MyCustomEvent *>(event);
        // custom event handling here
        return true;
    }

    return QWidget::event(event);
}
```

注意，`QWidget::event()`仍然为所有未处理的情况调用，并且返回值指示是否处理了事件;true值防止事件被发送到其他对象。

## 4、事件过滤

​	有时，对象需要查看(可能还需要截取)交付给另一个对象的事件。例如，对话框通常想要过滤一些小部件的按键;例如，修改 Return-key 处理。

​	`QObject::installEventFilter()`函数通过设置一个事件过滤器来启用此功能，导致指定的过滤器对象在其`QObject::eventFilter()`函数中接收目标对象的事件。事件筛选器在目标对象之前处理事件，允许它根据需要检查和丢弃事件。可以使用`QObject::removeEventFilter()`函数删除现有的事件过滤器。

​	当过滤器对象的`eventFilter()`实现被调用时，它可以接受或拒绝事件，并允许或拒绝对事件的进一步处理。如果所有事件过滤器都允许对事件进行进一步处理(每个过滤器都返回false)，则该事件将被发送到目标对象本身。如果其中一个停止处理(通过返回true)，目标和以后的任何事件过滤器都不会看到该事件。