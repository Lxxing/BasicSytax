# Qt源码解析 [索引](https://blog.csdn.net/xinqingwuji/article/details/118365888)

# Qt源码解析3-C++基础-位域

# 位域

声明具有以位为单位的明确大小的类数据成员。相邻的位域成员可以打包成共享和跨过各个字节。

位域声明是使用下列声明符的[类数据成员声明](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-data_members.html)：

标识符(可选) `:` 宽度

| 标识符 | -    | 正在声明的位域名称。名称是可选的：无名位域引入一个指定的填充位数 |
| ------ | ---- | ------------------------------------------------------------ |
| 宽度   | -    | 一个拥有大于或等于零，且小于或等于底层类型位数的整数[常量表达式](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/c-language-constant_expression.html)。大于零时，此为此位域将占据的位数。零值仅允许用于无名位域，并拥有特殊含义：它指定结构体定义中的下个位域会从分配单元边界开始。 |



|                                                       |      |            |
| ----------------------------------------------------- | ---- | ---------- |
| 标识符(可选) attr(可选) `:` 大小                      | (1)  |            |
|                                                       |      |            |
| 标识符(可选) attr(可选) `:` 大小 花括号或等号初始化器 | (2)  | (C++20 起) |
|                                                       |      |            |

位域的*类型*由[声明语法](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-declarations.html)的 声明说明符序列 引入.

| attr(C++11)          | -    | 可选的任何数量[属性](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-attributes.html)的序列 |
| -------------------- | ---- | ------------------------------------------------------------ |
| 标识符               | -    | 被声明的位域名。名字是可选的：无名位域引入指定数量的填充位   |
| 大小                 | -    | 值大于或等于零的[整型常量表达式](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-constant_expression.html#.E6.95.B4.E5.9E.8B.E5.B8.B8.E9.87.8F.E8.A1.A8.E8.BE.BE.E5.BC.8F)。大于零时，这是位域将占有的位数。值零仅对无名位域允许使用并具有特殊含义：它指定类定义中的下个位域将始于分配单元的边界。 |
| 花括号或等号初始化器 | -    | 此位域所使用的[默认成员初始化器](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-data_members.html#.E6.88.90.E5.91.98.E5.88.9D.E5.A7.8B.E5.8C.96) |

### 解释

位域中的位数设置其所能保有的值的极限：

```
#include <iostream>
struct S {
 // 三位的无符号位域，
 // 允许值为 0...7
 unsigned int b : 3;
};
int main()
{
    S s = {6};
    ++s.b; // 在位域中存储值 7
    std::cout << s.b << '\n';
    ++s.b; // 值 8 不适合此位域
    std::cout << s.b << '\n'; // 正式来说是由实现定义的行为，通常为 0
}
```

可能的输出：

```
7
0
```

多个相邻位域通常打包在一起（尽管此行为是实现定义的）：

```
#include <iostream>
struct S {
    // 将通常占用 2 字节：
    // 3 位：b1 的值
    // 2 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    // 3 位：不使用
    unsigned char b1 : 3, : 2, b2 : 6, b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}
```

可能的输出：

```
2
```

特殊的零大小无名位域可用于强行打破填充。它指定下个位域始于其分配单元的开始：

```
#include <iostream>
struct S {
    // 通常将占用 2 字节：
    // 3 位：b1 的值
    // 5 位：不使用
    // 6 位：b2 的值
    // 2 位：b3 的值
    unsigned char b1 : 3;
    unsigned char :0; // 开始新字节
    unsigned char b2 : 6;
    unsigned char b3 : 2;
};
int main()
{
    std::cout << sizeof(S) << '\n'; // 通常打印 2
}
```

可能的输出：

```
2
```

若位域所指定的大小大于其类型的大小，则值由类型所限制：[std::uint8_t](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-types-integer.html) b : 1000; 仍会保有 0 与 255 间的值。额外位成为不使用的填充位。

因为位域不必然始于一个字节的开始，故不能取位域的地址。指向位域的指针和非 const 引用是不可行的。从位域[初始化 const 引用](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-reference_initialization.html)时，将创建一个临时量（其类型是位域的类型），并以该位域的值复制初始化，而引用绑定到该临时量。

位域的类型只能是整型或枚举类型。

位域不能是[静态数据成员](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-static.html)。

没有位域[纯右值](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-value_category.html)：左值到右值转换始终生成位域底层类型的对象。

| 位域无[默认成员初始化器](mk:@MSITStore:D:\Work\Document\cppreference-zh-20200816.chm::/chmhelp/cpp-language-data_members.html#.E6.88.90.E5.91.98.E5.88.9D.E5.A7.8B.E5.8C.96)：int b : 1 = 0; 与 int b : 1 {0} 非良构。 | (C++20 前) |
| ------------------------------------------------------------ | ---------- |
| 在位域大小与默认初始化器有歧义的情况下，选择组成合法大小的最长记号序列：`int a;  const int b = 0;  struct S {    // 简单情况    int x1 : 8 = 42;               // OK；"= 42" 是 花括号或等号初始化器    int x2 : 8 { 42 };             // OK；"{ 42 }" 是 花括号或等号初始化器    // 歧义    int y1 : true ? 8 : a = 42;    // OK；不存在 花括号或等号初始化器    int y2 : true ? 8 : b = 42;    // 错误：不能赋值给 const int    int y3 : (true ? 8 : b) = 42;  // OK；"= 42" 是 花括号或等号初始化器    int z : 1 || new int { 0 };    // OK；不存在 花括号或等号初始化器  };` | (C++20 起) |

### 注解

位域的下列性质*由实现定义*

- 以范围外的值对有符号位域进行赋值或初始化，或对有符号位域进行自增越过其范围，所产生的值。
- 任何关于类对象中位域的实际分配细节



| 未显式标为 signed 或 unsigned 的 char、short、int、long 及 long long 位域是有符号还是无符号。例如，int b:3; 可能有值域 0..7 或 -4..3。 | (C++14 前) |
| ------------------------------------------------------------ | ---------- |
|                                                              |            |

在 C 编程语言中，位域的宽度不能超过底层类型的宽度。