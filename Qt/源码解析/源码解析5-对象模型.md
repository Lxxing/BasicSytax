# Qt源码解析 [索引](https://blog.csdn.net/xinqingwuji/article/details/118365888)

# Qt源码解析5-对象模型-QVariant源码

标准 C++ 对象模型为对象范例提供了非常有效的运行时支持。但它的静态性质在某些问题领域是不灵活的。图形用户界面编程是一个需要运行时效率和高度灵活性的领域。Qt 通过将 C++ 的速度与 Qt 对象模型的灵活性相结合来提供这一点。

Qt 将这些特性添加到 C++ 中：

- 一种非常强大的无缝对象通信机制，称为信号和槽

- 可查询和可设计的对象属性

- 强大的事件和事件过滤器

- 用于国际化的上下文字符串翻译

- 复杂的间隔驱动计时器，可以在事件驱动的 GUI 中优雅地集成许多任务

- 以自然方式组织对象所有权的分层和可查询对象树

- 受保护的指针 ( QPointer ) 在引用的对象被销毁时自动设置为 0，这与普通的 C++ 指针不同，后者在其对象被销毁时变为悬空指针

- 跨库边界工作的动态转换。

- 支持自定义类型创建。

许多这些 Qt 特性是使用标准 C++ 技术实现的，基于从QObject继承。其他的，比如对象通信机制和动态属性系统，需要Qt自己的Meta-Object Compiler（moc）提供的Meta-Object System。

元对象系统是 C++ 扩展，使该语言更适合真正的组件 GUI 编程。

# 1、重要课程

这些类构成了 Qt 对象模型的基础。

|    QMetaClassInfo     |               关于类的附加信息               |
| :-------------------: | :------------------------------------------: |
|       QMetaEnum       |              关于枚举器的元数据              |
|      QMetaMethod      |             关于成员函数的元数据             |
|      QMetaObject      |           包含有关 Qt 对象的元信息           |
|     QMetaProperty     |               关于属性的元数据               |
|       QMetaType       |          管理元对象系统中的命名类型          |
|        QObject        |              所有 Qt 对象的基类              |
| QObjectCleanupHandler |         监视多个 QObject 的生命周期          |
|       QPointer        |    提供指向 QObject 的受保护指针的模板类     |
|    QSignalBlocker     | QObject::blockSignals() 周围的异常安全包装器 |
|     QSignalMapper     |          捆绑来自可识别发送者的信号          |
|       QVariant        |      就像最常见的 Qt 数据类型的联合一样      |

# 2、Qt 对象：身份与价值

上面列出的 Qt 对象模型的一些附加功能要求我们将 Qt 对象视为身份，而不是值。值被复制或分配；身份被克隆。克隆意味着创建一个新身份，而不是旧身份的精确副本。例如，双胞胎有不同的身份。他们可能看起来相同，但他们有不同的名字、不同的位置，并且可能拥有完全不同的社交网络。

然后克隆身份是比复制或分配值更复杂的操作。我们可以在 Qt 对象模型中看到这意味着什么。

一个 Qt 对象...

可能有一个唯一的QObject::objectName ()。如果我们复制一个 Qt 对象，我们应该给这个副本起什么名字呢？
在对象层次结构中有一个位置。如果我们复制一个 Qt 对象，副本应该放在哪里？
可以连接到其他 Qt 对象以向它们发出信号或接收它们发出的信号。如果我们复制一个 Qt 对象，我们应该如何将这些连接转移到副本中呢？
可以在运行时添加未在 C++ 类中声明的新属性。如果我们复制一个 Qt 对象，副本是否应该包括添加到原始对象的属性？由于这些原因，Qt 对象应该被视为身份，而不是值。
身份是克隆的，而不是复制或分配的，克隆身份是比复制或分配值更复杂的操作。
因此，QObject和QObject的所有子类（直接或间接）都禁用了它们的复制构造函数和赋值运算符。