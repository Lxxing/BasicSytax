# Qt源码解析 [索引](https://blog.csdn.net/xinqingwuji/article/details/118365888)

# 源码解析6-系统封装-宏定义

走读源码时会看到很多不认识的宏

# 编译优化Q_LIKELY、Q_UNLIKELY

## 编译条件 __ GNUC __下的宏

```c++
#  define Q_LIKELY(expr)    __builtin_expect(!!(expr), true)
#  define Q_UNLIKELY(expr)  __builtin_expect(!!(expr), false)
```

if (likely(value))等价于if (value)
if (unlikely(value))等价于if (value)

**也就是说likely()和unlikely()从阅读和理解的角度是一样的。**
这两个宏在内核中定义如下：
\#define likely(x) __ builtin_expect(!!(x), 1)
\#define unlikely(x) __ builtin_expect(!!(x), 0)
这里的__built_expect()函数是gcc(version >= 2.96)的内建函数,提供给程序员使用的，目的是将"分支转移"的信息提供给编译器，这样编译器对代码进行优化，以减少指令跳转带来的性能下降。
_ _ buildin_expect((x), 1)表示x的值为真的可能性更大.
_ _ buildin_expect((x), 0)表示x的值为假的可能性更大.
**也就是说，使用likely(),执行if后面的语句的机会更大，使用unlikely(),执行else后面的语句机会更大一些。**

通过这种方式，编译器在编译过程中，会将可能性更大的代码紧跟着后面的代码，从而减少指令跳转带来的性能上的下降。 **功能总结就是添加cache的命中率，提高系统执行速度.** 

## 其他条件

其他条件都是空定义，理解其表示含义即可

```c++
#ifndef Q_LIKELY
#  define Q_LIKELY(x) (x)
#endif
#ifndef Q_UNLIKELY
#  define Q_UNLIKELY(x) (x)
#endif
```

